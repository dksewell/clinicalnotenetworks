pacman::p_load(lubridate,
dplyr,
magrittr,
tidygraph,
RSQLite,
DBI)
pat_id = "78340080308"
db =
dbConnect(SQLite(),
"E:/R01-SMART_cancer_care/smart_cancer_care.db")
site = "UCDavis"
include_med_students = FALSE
verbose = TRUE
alogs =
db %>%
tbl(paste0("access_logs_",site)) %>%
filter(PAT_OBFUS_ID == pat_id, # PAT_OBFUS_ID needs to be of same format (chr vs. numeric) as patient level data
NOTE_TYPE != "Telephone Encounter") %>%
collect() %>%
mutate(date_time = dmy_hms(ACCESS_TIME_CHAR)) %>% # Convert access_time_char to date
arrange(date_time) %>%
mutate(ACCESS_USER_OBFUS_ID = as.character(ACCESS_USER_OBFUS_ID), # This will help merge with note ids later.
log_event_number = 1:n()) %>%  # This is to help with several operations later
mutate(original_note_id = NEW_DATA_OBFUS_ID) # This might not be necessary, but I'd like to store the original note ID for potential future use.
beepr::beep(4)
#--------------------------------------
# Handle notes with view as first entry
#--------------------------------------
# Note: This needs to go before the med student portion.  To illustrate why,
#       consider the case where a note has its first entry as a view with the note
#       author as a med student.  Then we need there to be a modify by that med
#       student in the data in order to later transform the first non-med student
#       view into a modify (which happens in the med student part of the code).
first_entry_is_view =
alogs %>%
group_by(NEW_DATA_OBFUS_ID) %>%
# arrange(date_time) %>% # Not needed because we already arranged by this.
filter(row_number() == 1) %>%
ungroup() %>%
filter(EVENT_ACTION == "View")
if( nrow(first_entry_is_view) > 0 ){
# For each note with first entry as a view, create a new row to be
#   added to alogs that includes a modify of the note author.  Nothing
#   else is known, so any other choices are arbitrary.  Here's my
#   arbitrary choice: Set the date to be 1 week prior to earliest access
#   log date.  Everything else is set to be NA.
for(i in 1:nrow(first_entry_is_view)){
new_row_final =
new_row_temp =
alogs %>%
filter(NEW_DATA_OBFUS_ID == first_entry_is_view$NEW_DATA_OBFUS_ID[i]) %>%
arrange(date_time) %>%
filter(row_number() == 1) %>%
mutate(date_time = date_time - 7 * 24 * 60^2,
ACCESS_USER_OBFUS_ID = NOTE_AUTHOR_OBFUS_ID,
ACCESS_USER_PROV_TYPE = NOTE_AUTHOR_PROV_TYPE,
ACCESS_USER_CLINICIAN_TITLE = NOTE_AUTHOR_CLINICIAN_TITLE,
ACCESS_USER_PROV_SPECIALTY = NOTE_AUTHOR_PROV_SPECIALTY,
ACCESS_USER_PROVIDER_GENDER = NOTE_AUTHOR_PROVIDER_GENDER)
new_row_final[] = NA
new_row_final %<>%
mutate(date_time = new_row_temp$date_time - 7 * 24 * 60^2,
ACCESS_USER_OBFUS_ID = new_row_temp$NOTE_AUTHOR_OBFUS_ID,
ACCESS_USER_PROV_TYPE = new_row_temp$NOTE_AUTHOR_PROV_TYPE,
ACCESS_USER_CLINICIAN_TITLE = new_row_temp$NOTE_AUTHOR_CLINICIAN_TITLE,
ACCESS_USER_PROV_SPECIALTY = new_row_temp$NOTE_AUTHOR_PROV_SPECIALTY,
ACCESS_USER_PROVIDER_GENDER = new_row_temp$NOTE_AUTHOR_PROVIDER_GENDER,
log_event_number = max(alogs$log_event_number) + 1)
alogs %<>%
bind_rows(new_row_final)
}
rm(new_row_final,new_row_temp)
}
#--------------------------------------
# Deal with med students
#--------------------------------------
if(!include_med_students){
to_be_removed = NULL
# We'll eventually just delete all med students.  This is fine
#   for views, but not necessarily modifies.
med_student_authored_notes =
alogs %>%
filter(ACCESS_USER_PROV_TYPE == ".STUDENT: MEDICAL",
EVENT_ACTION == "Modify")
## If such notes exist, change authorship.
if(nrow(med_student_authored_notes) > 0){
to_be_added_to_alogs = alogs[0,]
for(j in 1:nrow(med_student_authored_notes)){
### First, check to see if there are any views.
note_views =
alogs %>%
filter(NEW_DATA_OBFUS_ID == med_student_authored_notes$NEW_DATA_OBFUS_ID[j],
EVENT_ACTION == "View")
### Second, check for an additional modify.
second_modify =
alogs %>%
filter(ACCESS_USER_PROV_TYPE != ".STUDENT: MEDICAL",
EVENT_ACTION == "Modify",
NEW_DATA_OBFUS_ID == med_student_authored_notes$NEW_DATA_OBFUS_ID[j]) %>%  # Yikes, forgot this in the previous version!
select(ACCESS_USER_OBFUS_ID,
ACCESS_USER_PROV_TYPE,
ACCESS_USER_CLINICIAN_TITLE,
ACCESS_USER_PROV_SPECIALTY,
ACCESS_USER_PROVIDER_GENDER)
#### If there are no other modifies nor views, this is all moot.
#     This is because we effectively have a note with no author
#     and no viewers.
if( (nrow(note_views) == 0) & (nrow(second_modify) == 0) ){
to_be_removed =
c(to_be_removed,
med_student_authored_notes$NEW_DATA_OBFUS_ID[j])
}else{
### If there is a second modify by a non-medical student
#     (and all other students should not be included in the db)
#     then set that person as the new author.
if(nrow(second_modify) > 0){
new_author =
second_modify[1,]
}else{
### If there's not an additional modify, authorship goes to
#     first physician view, else first view if no physician view.
#     Add an additional row to show a link
#     FROM healthcare provider TO note
note_views %<>%
mutate(phys_author = grepl("PHYSICIAN",ACCESS_USER_PROV_TYPE))
if(any(note_views$phys_author)) note_views %<>% filter(phys_author)
new_author = note_views[1,]
new_author$EVENT_ACTION = "Modify"
to_be_added_to_alogs %<>%
bind_rows(new_author %>%
select(-phys_author))
}
}
}
# Add new rows onto alogs.
to_be_added_to_alogs %<>%
distinct() %>%
mutate(log_event_number =
max(alogs$log_event_number) + 1:n())
alogs %<>%
bind_rows(to_be_added_to_alogs)
}
# OK, now delete all med student actions.
alogs %<>%
filter(ACCESS_USER_PROV_TYPE != ".STUDENT: MEDICAL")
# And delete all notes with no non-student views nor modifies
if(!is.null(to_be_removed)) alogs %<>% filter(!(NEW_DATA_OBFUS_ID %in% unique(to_be_removed)))
}else{
stop("If med students are to be included, then code needs to be written here to do so correctly.")
}
#--------------------------------------
# Handle multiple authorship
#--------------------------------------
if(verbose) cat("\n--- Handling clinical notes with multiple authorship ---\n")
## Find complex notes with multiple note authors
multiple_note_authors =
alogs %>%
group_by(NEW_DATA_OBFUS_ID) %>%
filter(EVENT_ACTION == "Modify") %>%
select(ACCESS_USER_OBFUS_ID) %>%
distinct() %>%
summarize(n_unique_authors = n()) %>%
filter(n_unique_authors > 1)
multiple_note_authors
nrow(multiple_note_authors) > 0
to_be_added_to_alogs = alogs[0,]
note_id = multiple_note_authors$NEW_DATA_OBFUS_ID[1]
note_id
today()
today() - mdy("5-16-2019")
alogs %<>% mutate(NEW_DATA_OBFUS_ID = paste(NEW_DATA_OBFUS_ID,"1",sep="-"))
### Get access logs just for this note
smaller_alogs =
alogs %>%
filter(NEW_DATA_OBFUS_ID == note_id)
smaller_alogs
note_id
## Find complex notes with multiple note authors
multiple_note_authors =
alogs %>%
group_by(NEW_DATA_OBFUS_ID) %>%
filter(EVENT_ACTION == "Modify") %>%
select(ACCESS_USER_OBFUS_ID) %>%
distinct() %>%
summarize(n_unique_authors = n()) %>%
filter(n_unique_authors > 1)
nrow(multiple_note_authors) > 0
to_be_added_to_alogs = alogs[0,]
note_id = multiple_note_authors$NEW_DATA_OBFUS_ID[1]
### Get access logs just for this note
smaller_alogs =
alogs %>%
filter(NEW_DATA_OBFUS_ID == note_id)
smaller_alogs
### Get index of modifies
modify_index = which(smaller_alogs$EVENT_ACTION == "Modify")
modify_index
### Create vector of current authors (just the first one to start with)
current_authors = smaller_alogs$ACCESS_USER_OBFUS_ID[modify_index[1]]
length(modify_index)
smaller_alogs
### Get index of modifies
modify_index = which(smaller_alogs$EVENT_ACTION == "Modify")
modify_index
current_authors
smaller_alogs$log_event_number[i]
i=2
alogs =
db %>%
tbl(paste0("access_logs_",site)) %>%
filter(PAT_OBFUS_ID == pat_id, # PAT_OBFUS_ID needs to be of same format (chr vs. numeric) as patient level data
NOTE_TYPE != "Telephone Encounter") %>%
collect() %>%
mutate(date_time = dmy_hms(ACCESS_TIME_CHAR)) %>% # Convert access_time_char to date
arrange(date_time) %>%
mutate(ACCESS_USER_OBFUS_ID = as.character(ACCESS_USER_OBFUS_ID), # This will help merge with note ids later.
log_event_number = 1:n()) %>%  # This is to help with several operations later
mutate(original_note_id = NEW_DATA_OBFUS_ID) %>%  # This might not be necessary, but I'd like to store the original note ID for potential future use, possibly for the next grant on viz.
mutate(NEW_DATA_OBFUS_ID = paste(NEW_DATA_OBFUS_ID,"01",sep="-"))
#--------------------------------------
# Handle notes with view as first entry
#--------------------------------------
# Note: This needs to go before the med student portion.  To illustrate why,
#       consider the case where a note has its first entry as a view with the note
#       author as a med student.  Then we need there to be a modify by that med
#       student in the data in order to later transform the first non-med student
#       view into a modify (which happens in the med student part of the code).
first_entry_is_view =
alogs %>%
group_by(NEW_DATA_OBFUS_ID) %>%
# arrange(date_time) %>% # Not needed because we already arranged by this.
filter(row_number() == 1) %>%
ungroup() %>%
filter(EVENT_ACTION == "View")
if( nrow(first_entry_is_view) > 0 ){
# For each note with first entry as a view, create a new row to be
#   added to alogs that includes a modify of the note author.  Nothing
#   else is known, so any other choices are arbitrary.  Here's my
#   arbitrary choice: Set the date to be 1 week prior to earliest access
#   log date.  Everything else is set to be NA.
for(i in 1:nrow(first_entry_is_view)){
new_row_final =
new_row_temp =
alogs %>%
filter(NEW_DATA_OBFUS_ID == first_entry_is_view$NEW_DATA_OBFUS_ID[i]) %>%
arrange(date_time) %>%
filter(row_number() == 1) %>%
mutate(date_time = date_time - 7 * 24 * 60^2,
ACCESS_USER_OBFUS_ID = NOTE_AUTHOR_OBFUS_ID,
ACCESS_USER_PROV_TYPE = NOTE_AUTHOR_PROV_TYPE,
ACCESS_USER_CLINICIAN_TITLE = NOTE_AUTHOR_CLINICIAN_TITLE,
ACCESS_USER_PROV_SPECIALTY = NOTE_AUTHOR_PROV_SPECIALTY,
ACCESS_USER_PROVIDER_GENDER = NOTE_AUTHOR_PROVIDER_GENDER)
new_row_final[] = NA
new_row_final %<>%
mutate(date_time = new_row_temp$date_time - 7 * 24 * 60^2,
ACCESS_USER_OBFUS_ID = new_row_temp$NOTE_AUTHOR_OBFUS_ID,
ACCESS_USER_PROV_TYPE = new_row_temp$NOTE_AUTHOR_PROV_TYPE,
ACCESS_USER_CLINICIAN_TITLE = new_row_temp$NOTE_AUTHOR_CLINICIAN_TITLE,
ACCESS_USER_PROV_SPECIALTY = new_row_temp$NOTE_AUTHOR_PROV_SPECIALTY,
ACCESS_USER_PROVIDER_GENDER = new_row_temp$NOTE_AUTHOR_PROVIDER_GENDER,
log_event_number = max(alogs$log_event_number) + 1)
alogs %<>%
bind_rows(new_row_final)
}
rm(new_row_final,new_row_temp)
}
if(!include_med_students){
to_be_removed = NULL
# We'll eventually just delete all med students.  This is fine
#   for views, but not necessarily modifies.
med_student_authored_notes =
alogs %>%
filter(ACCESS_USER_PROV_TYPE == ".STUDENT: MEDICAL",
EVENT_ACTION == "Modify")
## If such notes exist, change authorship.
if(nrow(med_student_authored_notes) > 0){
to_be_added_to_alogs = alogs[0,]
for(j in 1:nrow(med_student_authored_notes)){
### First, check to see if there are any views.
note_views =
alogs %>%
filter(NEW_DATA_OBFUS_ID == med_student_authored_notes$NEW_DATA_OBFUS_ID[j],
EVENT_ACTION == "View")
### Second, check for an additional modify.
second_modify =
alogs %>%
filter(ACCESS_USER_PROV_TYPE != ".STUDENT: MEDICAL",
EVENT_ACTION == "Modify",
NEW_DATA_OBFUS_ID == med_student_authored_notes$NEW_DATA_OBFUS_ID[j]) %>%  # Yikes, forgot this in the previous version!
select(ACCESS_USER_OBFUS_ID,
ACCESS_USER_PROV_TYPE,
ACCESS_USER_CLINICIAN_TITLE,
ACCESS_USER_PROV_SPECIALTY,
ACCESS_USER_PROVIDER_GENDER)
#### If there are no other modifies nor views, this is all moot.
#     This is because we effectively have a note with no author
#     and no viewers.
if( (nrow(note_views) == 0) & (nrow(second_modify) == 0) ){
to_be_removed =
c(to_be_removed,
med_student_authored_notes$NEW_DATA_OBFUS_ID[j])
}else{
### If there is a second modify by a non-medical student
#     (and all other students should not be included in the db)
#     then set that person as the new author.
if(nrow(second_modify) > 0){
new_author =
second_modify[1,]
}else{
### If there's not an additional modify, authorship goes to
#     first physician view, else first view if no physician view.
#     Add an additional row to show a link
#     FROM healthcare provider TO note
note_views %<>%
mutate(phys_author = grepl("PHYSICIAN",ACCESS_USER_PROV_TYPE))
if(any(note_views$phys_author)) note_views %<>% filter(phys_author)
new_author = note_views[1,]
new_author$EVENT_ACTION = "Modify"
to_be_added_to_alogs %<>%
bind_rows(new_author %>%
select(-phys_author))
}
}
}
# Add new rows onto alogs.
to_be_added_to_alogs %<>%
distinct() %>%
mutate(log_event_number =
max(alogs$log_event_number) + 1:n())
alogs %<>%
bind_rows(to_be_added_to_alogs)
}
# OK, now delete all med student actions.
alogs %<>%
filter(ACCESS_USER_PROV_TYPE != ".STUDENT: MEDICAL")
# And delete all notes with no non-student views nor modifies
if(!is.null(to_be_removed)) alogs %<>% filter(!(NEW_DATA_OBFUS_ID %in% unique(to_be_removed)))
}else{
stop("If med students are to be included, then code needs to be written here to do so correctly.")
}
## Find complex notes with multiple note authors
multiple_note_authors =
alogs %>%
group_by(NEW_DATA_OBFUS_ID) %>%
filter(EVENT_ACTION == "Modify") %>%
select(ACCESS_USER_OBFUS_ID) %>%
distinct() %>%
summarize(n_unique_authors = n()) %>%
filter(n_unique_authors > 1)
multiple_note_authors
to_be_added_to_alogs = alogs[0,]
to_be_removed = NULL
note_id
note_id = multiple_note_authors$NEW_DATA_OBFUS_ID[1]
note_id
### Get access logs just for this note
smaller_alogs =
alogs %>%
filter(NEW_DATA_OBFUS_ID == note_id)
### Get index of modifies
modify_index = which(smaller_alogs$EVENT_ACTION == "Modify")
modify_index
### Create vector of current authors (just the first one to start with.  It will expand as we go.)
current_authors = smaller_alogs$ACCESS_USER_OBFUS_ID[modify_index[1]]
current_authors
i=2
smaller_alogs$ACCESS_USER_OBFUS_ID[i] %in% current_authors
smaller_alogs$ACCESS_USER_OBFUS_ID[i]
current_authors
smaller_alogs$ACCESS_USER_OBFUS_ID[i] %in% current_authors
modify_index[i]
string
string = "foo12"
substr(string,1,nchar(string) - 2)
as.numeric(substr(string,nchar(string) - 1,nchar(string))) + 1
paste(substr(string,1,nchar(string) - 2),
as.numeric(substr(string,nchar(string) - 1,nchar(string))) + 1)
paste(substr(string,1,nchar(string) - 2),
as.numeric(substr(string,nchar(string) - 1,nchar(string))) + 1,
sep = "")
## Create helper function to modify the DATA_OBFUS_ID
augment_id = function(string){
paste(substr(string,1,nchar(string) - 2),
as.numeric(substr(string,nchar(string) - 1,nchar(string))) + 1,
sep = "")
}
note_id
augment_id(note_id)
sprintf("%02d", 1)
sprintf("%02d", 2)
sprintf("%02d", 2:5)
sprintf("%02d", 2:15)
sprintf("%02d", as.numeric(substr(string,nchar(string) - 1,nchar(string))) + 1)
string = "foo04
string = "foo04"
## Create helper function to modify the DATA_OBFUS_ID
augment_id = function(string){
paste(substr(string,1,nchar(string) - 2),
sprintf("%02d", as.numeric(substr(string,nchar(string) - 1,nchar(string))) + 1),
sep = "")
}
augment_id("foo04")
rm(string)
## Create helper function to modify the DATA_OBFUS_ID
augment_id = function(string){
paste(substr(string,1,nchar(string) - 2),
sprintf("%02d", as.numeric(substr(string,nchar(string) - 1,nchar(string))) + 1),
sep = "")
}
augment_id(note_id)
note_id
smaller_alogs[modify_index[i],] %>%
mutate(EVENT_ACTION == "View")
